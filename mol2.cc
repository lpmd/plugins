//
//
//

#include "mol2.h"

#include <lpmd/util.h>
#include <lpmd/simulation.h>
#include <algorithm>
#include <cctype>
#include <iomanip>

using namespace lpmd;

Mol2Format::Mol2Format(std::string args): Plugin("mol2", "2.0")
{
 ParamList & params = (*this);
 //
 DefineKeyword("file");
 DefineKeyword("each", "1");
 AssignParameter("replacecell", "false");
 // hasta aqui los valores por omision
 ProcessArguments(args);
 writefile = params["file"];
 interval = int(params["each"]);
 rcell = params["replacecell"];
}

Mol2Format::~Mol2Format() { }

void Mol2Format::ShowHelp() const
{
 std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
 std::cout << " Module Name        = mol2                                                     \n";
 std::cout << " Problems Report to = admin@lpmd.cl                                            \n";
 std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
 std::cout << " General Info      >>                                                          \n";
 std::cout << "      This module is used to read/write atomic configurations files in MOLDY2  \n";
 std::cout << "      format.                                                                  \n";
 std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
 std::cout << " General Options   >>                                                          \n";
 std::cout << "      file          : Input/output file that contains the atomic configurations\n";
 std::cout << "                      in MOL2 format.                                          \n";
 std::cout << "      each          : Determines how often (each how many time-steps) the      \n";
 std::cout << "                      input/output file must be read/written.                  \n";
 std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
 std::cout << " Example                                                                       \n";
 std::cout << " Calling the module in a control file :                                        \n";
 std::cout << " input module=mol2 file=inputfile.mol2                                         \n";
 std::cout << " output module=mol2 file=outputfile.mol2 each=5                              \n\n";
 std::cout << "      The plugin is used to read and write atomic configurations in MOL2 format.\n";
 std::cout << "      The file extension (.mol2) is irrelevant, what matters is the module     \n";
 std::cout << "      loaded (module=mol2).                                                    \n";
 std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
}

void Mol2Format::WriteHeader(std::ostream & os, SimulationHistory * sh) const
{
 assert(&os != 0); //icc 869
 assert(sh >= (void *)NULL); //icc869
 // Mol2 no tiene ningun header especial
}

void Mol2Format::WriteCell(std::ostream & out, Configuration & con) const
{
 BasicParticleSet & part = con.Atoms();
 //BasicCell & cell = con.Cell();
 out << "@<TRIPOS>MOLECULE\n";
 out << "autogenerated\n";
 out << " " << part.Size() << " 0 0 0 0\n";
 out << "SMALL\n";
 out << "GASTEIGER\n";
 out << "Energy = 0\n\n";
 out << "@<TRIPOS>ATOM\n";
 for (long int i=0;i<part.Size();++i)
 {
  const Vector & pos = part[i].Position();
  out << std::setw(8) << (i+1);
  std::string sy = part[i].Symbol();
  std::transform(sy.begin(), sy.end(), sy.begin(), (int(*) (int)) std::toupper);
  out << "  " << sy << "    ";
  out << pos << " " << part[i].Symbol() << "   0  LIG0      0.0000\n";
 }
 out << "@<TRIPOS>BOND\n\n";
}

void Mol2Format::ReadHeader(std::istream & is) const
{
 assert (&is != 0); //icc 869
 // Mol2 no tiene header especial para leer
}

bool Mol2Format::ReadCell(std::istream & is, Configuration & con) const
{
 BasicParticleSet & part = con.Atoms();
 assert(part.Size() == 0);
 if ((*this)["replacecell"] == "true") throw PluginError("mol2", "This format does not contain any cell vectors.");
 long natoms=0;
 if(is.eof()) return false;
 while(!is.eof())
 {
  std::string tmp;
  getline(is,tmp);
  std::cerr << tmp << '\n';
  if(tmp[0]!='#')
  {
   if (tmp=="@<TRIPOS>MOLECULE")
   {
    getline(is,tmp);
    getline(is,tmp);
    Array<std::string> linea = StringSplit(tmp,' ');
    natoms = (long)atof(linea[0].c_str()); 
   }
   if (tmp=="@<TRIPOS>ATOM")
   {
    if (natoms <=0) throw PluginError("mol2","Atoms number in mol2 file was not be read!");
    else
    {
     for (int i=0;i<natoms;i++)
     {
      getline(is,tmp);
      Array<std::string> linea = StringSplit(tmp,' ');
      std::string symb = linea[1];
      lpmd::Vector pos(atof(linea[2].c_str()),atof(linea[3].c_str()),atof(linea[4].c_str()));
      if(symb.length()>1)
      {
       for(unsigned int j=1;j<symb.length();j++)
       {
	symb[j]=tolower(symb[j]);
       }
      }
      part.Append(Atom(symb,pos));
     }
    }
    return true;
   }
  }
 }
 return false;
}

// Esto se incluye para que el modulo pueda ser cargado dinamicamente
Plugin * create(std::string args) { return new Mol2Format(args); }
void destroy(Plugin * m) { delete m; }

